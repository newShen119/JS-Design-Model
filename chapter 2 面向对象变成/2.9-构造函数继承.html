<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script type="text/javascript">
	
	// create class
	function SuperClass(id) {

		// 引用类型共有属性
		this.books = ["js", "html", "css"];

		// 值类型共有属性
		this.id = id;
	};

	SuperClass.prototype.showBooks = function() {
		console.log(this.books);
	};

	// create class
	function SubClass(id) {

		// 构造函数继承：改变变数的执行环境而执行函数，即赋值函数、属性（可以自己传值）;
		SuperClass.call(this, id);
	};

	var sub1 = new SubClass('957');
	console.log(sub1);

	//构造函数继承的缺点：单单使用构造函数，无法继承父类的prototype，如果需要继承，只将prototype里面的属性和方法写到构造函数中去 如：

	function SuperClass(id) {

		// 引用类型共有属性
		this.books = ["js", "html", "css"];

		// 值类型共有属性
		this.id = id;

		// 但是如下这种方法违背了代码复用的原则
		this.showBooks = function() {
			console.log(this.id);
		};

		this.getName = function() {
			console.log(this.name);
		};
	}

</script>
</html>